\subsection{Lessons learned$^{\odot}$}
None of the MAKo team member had experience with Jason as a programming language before the research lab.
The first thing that caused problems was that Jason was quite slow when it comes to communication between agents.
Since agents most times needed some information from others and could not continue with their reasoning until this information was given, communication was an extreme bottleneck.
Extreme delay was observed when the group tried to exchange information about the graph.
The first approach was to communicate everything that an agent perceives, while exploring the graph, to every other agent.
The reason behind this was to have every agent store the full knowledge about the until then explored (sub-)graph.
This course of action was quickly discarded, because agents were not able to do actions while processing all the incoming messages.
The next attempt to reduce communication was to implement a so called "cartographer" agent.
The purpose of this agent was to have an additionally agent in the background that gathers all the information about the map that all 28 agents perceive.
With that cartographer agent the amount of communication was reduced and agents could act like intended, because now they just sent their percepts to the cartographer agent and they had not to deal with incoming messages of the other 27 agents.
The drawback of this approach revealed when it came to querying the cartographer agent for information, for instance when an agent wanted to know if a vertex was already surveyed or how he could reach given vertex.
As mentioned before, processing the received messages is quite slow and so it happened that the cartographer agent was not able to handle messages in time.
It occurred that agents asked about some specific vertex which the cartographer agent should have known about, because some other agent already informed him about that particular vertex.
They got no answer due to the fact that the cartographer agent had not processed the message yet.
That's why this approach was also discarded.
The next idea, which worked in the end, was to use a Java object, the so called JavaMap, for the purpose of storing and processing graph information.
Internal actions were used to obtain the required information about the graph.
For instance the internal action \texttt{getBestHopToVertex} calculates the shortest path and returns, for a given target node, the next vertex where the agent has to go to.
Another issue arose initially during the contest.
If a Term in Jason contains a dash, it is interpreted as an arithmetic expression.
We observed this during our first match against a team that had a dash in its name.
So instead of handling \texttt{GOAL-DTU1} as a literal identifying an enemy agent, our agents tried to subtract \texttt{DTU1} from \texttt{GOAL} which lead to exceptions.
The result was that every reasoning which considered the name of an enemy agent failed.
We immediately fixed it, so that in the next matches we took this possibility of having a dash in the team name into account.
% TODO: introductory part
% TODO: final part
% TODO: these are from the TOC
% TODO: rewrite this a bit because it is covered quite well in @adaudrich's part. A lot can be kept to remind the reader what we were talking about. But we should not start explaining everything all over again.
