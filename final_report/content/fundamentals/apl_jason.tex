%TODO introduce ``belief base'' in AS(L)
%TODO introduce ``plan library'' in AS(L)
\subsubsection[Jason.]{Jason.$^\circ$}
This section gives a quick overview of Jason, which is an interpreter for AgentSpeak(L). All information if not marked differently is taken from Bordini et al.~\cite{bordini_jason_2005}. Besides being an interpreter, Jason extends AgentSpeak(L) by several concepts. The most important ones will be discussed in this section.

With Jason, terms can represent more than a constant or a variable. They can be strings, integer or floating point numbers or lists of terms. Therefore, more complex programmatic operations and arithmetic expressions are possible with Jason. Furthermore, Jason allows annotations for beliefs and triggering events. With these annotations, metadata can be added to plans and beliefs which can be accessed programmatically. \autoref{lst:jason_annotations} shows the earlier used initial beliefs with added annotations. The \texttt{source} annotation is the only one with its meaning predefined by Jason. It expresses the source of the information. If an agent determined something itself, the \texttt{source} is \texttt{self}. Did the agent receive the information as a perception of the environment, then the \texttt{source} will be \texttt{percept}. The source can also be a constant identifying a different agent if that agent is the source for this information. With the example given in \autoref{lst:jason_annotations}, an achievement goal \texttt{?~hasCoffee(X)[reliability(Y)]} will bind \texttt{X} to \texttt{john} and \texttt{Y} to \texttt{0.3}. The \texttt{reliability} has no further meaning unless the value bound to \texttt{Y} is used later.
\begin{lstlisting}[caption={Annotation of beliefs in Jason.}, label=lst:jason_annotations]
  ~hasCoffee(jane)[source(self)].
  ~hasCoffee(john)[source(percept), reliability(0.3)].
\end{lstlisting}

Another concept added to AgentSpeak(L) through Jason is called \emph{internal actions}. It was first introduced and implemented by Bordini et al.~\cite{bordini_agentspeak_2002}. Most characteristic for these actions is that they do not affect the environment in which the agents are located in. This means they have no effect on the external world but only on the internal states of the agents as the name suggests. Hence, any effects of internal actions occur immediately after the action execution instead of only after the next environment processing cycle. As a result, internal actions can not only be used within a plan's body but also in its context. % all this information is from p. 1297
Internal actions start with a dot followed by a library identifier, another dot and finally the action name. Bordini et al.~\cite{bordini_agentspeak_2002} implemented various internal actions which are not identified by any explicitly named library. These methods reside in the so called \emph{standard library} and omit the library declaration when being called. An example for this is \texttt{.gte(X,Y)} which returns the truth value of \texttt{X}$\geq$\texttt{Y}. A realisation of the same function outside the standard library could e.g. be called \texttt{.math.gte(X,Y)}. The standard library is included in Jason. Furthermore, Jason extends this library by multiple actions including multiple list operations like sorting or retrieving the minimum. Developers can write additional internal actions in Java or any other programming language which supports the programming framework Java Native Interface. %11

Arguably, the most important  internal action is \texttt{.send}. This action enables inter-agent communication as initially proposed and implemented by Vierira et al.~\cite{vieira_formal_2007}. It is similar to KQML performatives which had been introduced in SECTIONXYZ. % TODO if we have KQML from the seminar talks, refer to it.
\begin{lstlisting}[caption={Parameters of the internal action \texttt{.send} and an example.}, label=lst:jason_send]
  .send(Receiver, Illocutionary_force, Message_content).%\label{l:jason_send}%
  .send([explorer1, saboteur2], tell, ~hasCoffee(john)).%\label{l:jason_sendInstance}%
\end{lstlisting}
In \autoref{l:jason_send} of \autoref{lst:jason_send} the structure of the \texttt{.send} action is shown. \autoref{l:jason_sendInstance} shows an example usage of this action. The \texttt{Receiver} is the identifying name or a list of identifying names for the agent(s) to which the message should be addressed to. The \texttt{Illocutionary_force} is a constant that specifies what all recipients should do with the message. It can be:
\begin{itemize}
  \item \texttt{tell}: add the \texttt{Message_content} to the recipient's belief base.
  \item \texttt{untell}: remove the \texttt{Message_content} from the recipient's belief base.
  \item \texttt{achieve}: add the \texttt{Message_content} as an achievement goal to the recipient.
  \item \texttt{unachieve}: make the recipient remove the achievement goal \texttt{Message_content}.
  \item \texttt{tellHow}: \texttt{Message_content} is added to the recipient's plan library.
  \item \texttt{untellHow}: \texttt{Message_content} is removed from the recipient's plan library.
  \item \texttt{askIf}: asks if \texttt{Message_content} is in the recipient's belief base.
  \item \texttt{askOne}: asks for the first belief matching \texttt{Message_content}.
  \item \texttt{askAll}: asks for all beliefs matching \texttt{Message_content}.
  \item \texttt{askHow}: demand all plans a recipient has that match the triggering event given in the \texttt{Message_content}.
\end{itemize}
Jason automatically processes the messages as needed when a message arrives at an agent. %TODO should we talk about an agent's inbox?
A developer can override Jason's default behaviour if further or different processing is needed. Jason also automatically adds \texttt{source} annotations. This allows agents to determine the sender of any received message.

Jason also allows running multi-agent systems over networks in a distributed manner. Hence, the workload can be distributed over multiple machines. SACI~\cite{hubner_saci_2000} and JADE~\cite{bellifemine_jade_2005} are the two fully implemented distributed architectures usable out of the box with Jason \cite{bordini_programming_2007}. Yet, Fernández et al.~\cite{fernandez_evaluating_2010} could not prove the intended performance benefits. The authors tested both SACI and JADE with Jason where one hosts would run the environment and the other one the agents. They increased both the amount of agents as well as the size of the environment. Fernández et al.~\cite{fernandez_evaluating_2010} saw that with increasing complexity, the system became slower compared to when agents and the environment were run on a single machine. This was due to the added communication cost between the two hosts although connected by Gigabit Ethernet. As a result, a distributed infrastructure with Jason is only advisable, if the workload cannot be handled by one host alone. In our case, replying in time has such an importance that trying to keeping the workload processable by one host alone would be the preferred strategy.

Given the Mars scenario, Jason can be used to implement a suitable multi-agent system. In fact, two teams successfully participated in the 2013 Multi-Agent Programming Contest by using Jason \cite{ahlbrecht_multi_2013}.% p.367
The scenario of 2013 is comparable to the scenario of 2014 \cite{ahlbrecht_mapc_2014}. % p.1,9
