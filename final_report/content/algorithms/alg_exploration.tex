%%%%%%%%%%%%%%%%%%
\subsection[Exploration]{Exploration$^\star$}\label{alg:exploration}
One precondition of the Agents on Mars Scenario is that all agents start with an empty belief base. Each agent does not know about its local and global environment. Of course every agent gets beliefs about its local environment very quickly by receiving percepts from the server. But the agent still does not know about the global environment. For our strategies it is crucial to have as much information about the overall environment as possible. Just think about finding and building the best global zones or pathfinding. So it is important to store somehow information about the map like vertices, edges between vertices, paths and agent positions. In \autoref{alg:map_cartographer} our initial approach with its down- and up-sides is described. After that a basic overview over the Distance-Vector-Algorithm and the impact on our map building approach is given in \autoref{alg:map_dv}. Finally this chapter concludes with a description of the second approach we used and sticked to in \autoref{alg:map_javamap}


%%%%%%%%%%%%%%%%%%
\subsubsection[Cartographer Agent]{Cartographer Agent$^\star$}\label{alg:map_cartographer}
We decided very early in our development process that we do not want to store information which is needed by every agent in each single agent. The intention behind this decision was to reduce the effort in synchronizing and maintaining data between the single agents. Our initial approach was to install one omniscient pseudo agent we called the ``cartographer'' agent. The cartographer agent represented a map and had the only purpose to calculate shortest paths between given vertices and to store vertex and edge information like traversing costs, edges between vertices and vertex values. Every agent told the cartographer agent about its environment related beliefs and the cartographer agent stored these beliefs. Environment related beliefs are illustrated in the listing below:

\begin{itemize}
  \item \texttt{visibleEntity(<Vehicle>,<Vertex>,<Team>,<Disabled>)}
  \item \texttt{position(<Vertex>)}
  \item \texttt{visibleVertex(<Vertex>,<Team>)}
  \item \texttt{probedVertex(<Vertex>,<Value>)}
  \item \texttt{visibleEdge(<VertexA>,<VertexB>)}
  \item \texttt{surveyedEdge(<VertexA>,<VertexB>,<EdgeCosts>)}
\end{itemize}

 If an agent needed to know a shortest path, it just queried the cartographer agent and got the shortest path as an answer. Or if an agent needs to know if an vertex was already probed or surveyed, it just queried the cartographer. Shortly after implementing this approach, we encountered two major problems, which both resulted in serious performance issues. One problem was that pathfinding, which was done with the help of the Dijkstra-Algorithm, was executed every time an agent asked for a shortest path. This led to a lot of redundant calculation and processing in the cartographer agent. The second problem was related to communication between agents. To understand the latter problem, one need to know that Jason uses a message box system for communication between agents. This means that every message a sender sends to a receiver is queued in the receivers message inbox. In every Jason lifecycle only one message is processed. Although a Jason lifecycle is a lot shorter than a server lifecycle, still after some execution time the inbox of the cartographer agent was so full, that the processing of messages lagged far behind the receiving of these messages. Both issues resulted in blocked agents, which had been waiting for the response of their queries for rounds.


%%%%%%%%%%%%%%%%%%
\subsubsection[Distance-Vector Routing Protocol]{Distance-Vector Routing-Protocol$^\star$}\label{alg:map_dv}
To tackle the problem of repeating calculations of shortest paths, we used the \emph{Distance-Vector Routing Protocol}\cite{wiki:dvrp}(short: DV). DV is a routing protocol based on the Bellman-Ford algorithm\cite{wiki:bellman_ford}. DV can be executed on a network of nodes. The basic idea is that each node informs all of its neighbor nodes about its belief base. The informed node then updates its belief base and informs all of its neighbors also and so on. And some point all information is propagated through the whole network and all nodes have a consistent belief base.


What is it? How is it used in our context? What are advantages we gain from it? What is problematic (speed loss)?

%%%%%%%%%%%%%%%%%%
\subsubsection[JavaMap]{JavaMap$^\star$}\label{alg:map_javamap}