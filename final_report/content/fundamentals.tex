In this section we discuss the existing technologies, algorithms and approaches that we took into account while developing this project.
In the first subsection \autoref{fun:mapc}, the Multi-Agent Programming Contest is briefly described.
This will introduce the primary task that we had to solve in our research lab as well as the basic rules of the tournament we were participating in with our solution.
In the following \autoref{fun:apc} we describe the basic theoretical concepts used for modeling multi-agent systems.
Starting with the model of a single agent using the concepts of beliefs, desires and intentions, we then discuss the communication and decision making principles in multi-agent environments.
In the last subsection \autoref{fun:apl} of this section the review of existing agent programming languages is given.
The general syntax overview as well as the basic architecture description of each language is presented.
And as the conclusion we justify our choice of agent programming language for the project.

\subsection[The Multi-Agent Programming Contest]{The Multi-Agent Programming Contest$^{\odot/\circ}$}\label{fun:mapc}
\input{content/fundamentals/mapc.tex}

\subsection[Agent Programming Concepts]{Agent Programming Concepts$^{\blacktriangle}$}\label{fun:apc}
In order to design our own multi-agent system and participate in the \emph{Multi-Agent Programming Contest}, it is essential to understand some basic concepts of agent programming.
In this section, several recurring agent programming concepts are introduced.
\autoref{fun:BDI} describes the concept of BDI model which is commonly used in agent programming.
A brief architecture of the BDI model as well as the explanation of each component in the BDI model are presented.
Since BDI agents' behaviour may be complex in multi-agent systems, the correctness of agents’ behaviour should be ensured.
Formal methods use high-level abstractions to present agents for solving the correctness challenge. The concept of formal methods and several different logics used in formal methods are explained in \autoref{fun:formal_methods} .
\autoref{fun:negotiation} introduces the concepts of negotiation and argumentation,which are needed for multi-agents to cooperate.
Negotiation messages, agents modelling for negotiation and different types of arguments which can be used during negotiation are discussed in this part.

\input{content/fundamentals/BDI.tex}

\subsubsection[Formal Methods]{Formal Methods$^\diamond$}\label{fun:formal_methods}
\input{content/fundamentals/formal_methods.tex}

\subsubsection[Negotiation and Argumentation]{Negotiation and Argumentation$^\diamond$}\label{fun:negotiation}
\input{content/fundamentals/negotiation_argumentation.tex}

\subsection[Agent Programming Languages]{Agent Programming Languages$^\circ$}\label{fun:apl}
Currently, multiple agent frameworks are available for developing multi-agent applications.
% An overview of existing tools and techniques is given by Mangina~\cite{Mangina} in the context of the European Network of Excellence for Agent-Based Computing. % TODO maybe this fits better in the general part (parent section) – btw, this is nearly a quote to the original's papers abstract… -> that's why i put a citation there -> lol her name is Mangina -> I really laughed at this one. I've left this sentence out for now because it does not mention anything we are discussing but JADE.
We investigated several agent programming languages, for their suitability for the \mars{}.
Our goal was to determine which specialised language we wanted to use for multi-agent programming, if any.
The following sections present the basic structure of various languages together with examples.
These examples are unrelated to the \mars{} and are kept simple for ease of understanding.
Using the Mars-scenario for examples instead would have meant to either make them complex or to trivialise them to a point where they become too superficial to suit the scenario.
\autoref{fun:apl_sitCalc} first introduces the situation calculus.
Although not an agent programming language, it serves as a foundation of the logic programming language GOLOG presented in \autoref{fun:apl_golog}.
It also helps in understanding the subsequent \autoref{fun:apl_flux} which summarises the main concepts of FLUX.
FLUX is another logic programming language which was partly motivated by the flaws of GOLOG.
\autoref{fun:apl_jadex} introduces a Java-based agent programming language.
After that, AgentSpeak(L) is presented in \autoref{fun:apl_asl} which is another logic programming language.
Jason is an interpreter for this language and is discussed in \autoref{fun:apl_jason}.
The section focuses mainly on the extensions that Jason adds to AgentSpeak(L).
The final \autoref{fun:apl_choice} considers the previously presented agent programming languages and explains our decision for choosing Jason.

\input{content/fundamentals/apl_sitCalc}

\input{content/fundamentals/apl_golog}

\input{content/fundamentals/apl_flux}

\input{content/fundamentals/apl_jadex}

\input{content/fundamentals/apl_asl}

\input{content/fundamentals/apl_jason}

\input{content/fundamentals/apl_choice}
